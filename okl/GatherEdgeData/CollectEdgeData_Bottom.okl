kernel void CollectEdgeData_Bottom(const int Nfaces,
                                   const int * restrict  EdgeData,
                                   const dfloat * restrict  B,
                                   dfloat * restrict  bL,
                                   dfloat * restrict  bR)
{
    for (int ifa_base=0; ifa_base<Nfaces; ifa_base+=Nedgepad; outer0)
    {



        for (int ifa_inner = 0; ifa_inner < Nedgepad; ifa_inner++; inner1)
        {
            for(int i=0; i<ngl; i++; inner0)
            {

                const int ifa = ifa_base + ifa_inner;

                if (ifa<Nfaces)
                {
                    const int iel           =EdgeData[8*ifa];       //left element
                    const int ier           =EdgeData[8*ifa+1];       //right element
                    const int isl           =EdgeData[8*ifa+2];       //side within left element
                    const int isr           =EdgeData[8*ifa+3];      //side within right element
                    const int ireversed     =EdgeData[8*ifa+4];           //is order reversed? 0=yes, 1=no
                    const int cpuL          =EdgeData[8*ifa+5];     // rank of cpuL
                    const int cpuR          =EdgeData[8*ifa+6];     // rank of cpuR


                    const int increment = (1-ireversed)*(ngl-1-i) + ireversed*i;
                    int idxL,idxR;
                    const int edgeIDX=ifa*ngl + i;      //for edge wise spatial values (BOTTOM)



                    bL[edgeIDX] = zero;

                    bR[edgeIDX] = zero;



                    if (procID == cpuL)
                    {
                        switch(isl)
                        {
                        case (0): //bottom side
                            idxL = iel*ngl2+i;
                            break;
                        case (2): //top side
                            idxL = iel*ngl2+ngl2-ngl+i;
                            break;
                        case (3): //left side
                            idxL = iel*ngl2+i*ngl;
                            break;
                        case (1): //right side
                            idxL = iel*ngl2+(i+1)*ngl-1;
                            break;

                        }





                        bL[edgeIDX] = B[idxL];

                    }







                    if (procID == cpuR)
                    {
                        switch(isr)
                        {
                        case (0): //bottom side
                            idxR = ier*ngl2+increment;
                            break;
                        case (2): //top side
                            idxR = ier*ngl2+ngl2-ngl+increment;
                            break;
                        case (3): //left side
                            idxR = ier*ngl2+increment*ngl;
                            break;
                        case (1): //right side
                            idxR = ier*ngl2+(increment+1)*ngl-1;
                            break;

                        }
                        bR[edgeIDX] = B[idxR];

                    }


                    // EXTERIOR BOUNDARY CASE!


                    if (cpuL==-1)
                    {
                        bL[edgeIDX] = bR[edgeIDX];

                    }
                    if (cpuR==-1)
                    {
                        bR[edgeIDX] = bL[edgeIDX];

                    }


                }


            }//inner0 loop


        }//outer0 loop


    }//end kernel
