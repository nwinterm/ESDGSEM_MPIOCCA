
#define InitQNodal(x[idxR],y[idxR],q1,q2,q3,t,bL[edgeIDX])				\
      {		  barrier(localMemFence);							\

	q1 = (8.0+cos(x[idxR])*sin(y[idxR])*cos(t)-bL[edgeIDX]);					\
	q2 = 0.5*(8.0+cos(x[idxR])*sin(y[idxR])*cos(t)-bL[edgeIDX]);					\
	q3 = 1.5*(8.0+cos(x[idxR])*sin(y[idxR])*cos(t)-bL[edgeIDX]);					\
      }

#define InitQNodal(x[idxL],y[idxL],q1,q2,q3,t,bR[edgeIDX])					\
      {		  barrier(localMemFence);							\

	q1 = (8.0+cos(x[idxL])*sin(y[idxL])*cos(t)-bR[edgeIDX]);					\
	q2 = 0.5*(8.0+cos(x[idxL])*sin(y[idxL])*cos(t)-bR[edgeIDX]);					\
	q3 = 1.5*(8.0+cos(x[idxL])*sin(y[idxL])*cos(t)-bR[edgeIDX]);					\
      }

kernel void CollectEdgeData(const int Nfaces,const int * EdgeData,const dfloat * Q,const dfloat * x,const dfloat * y,const dfloat * normx,const dfloat * normy,const dfloat * bL, const dfloat * bR, dfloat * qL, dfloat * qR,const dfloat t)
{
        for (int ifa=0;ifa<Nfaces;ifa++;outer0){


             for(int i=0;i<ngl;i++;inner0){
                const int iel           =EdgeData[8*ifa];       //left element
                const int ier           =EdgeData[8*ifa+1];       //right element
                const int isl           =EdgeData[8*ifa+2];       //side within left element
                const int isr           =EdgeData[8*ifa+3];      //side within right element
                const int ireversed     =EdgeData[8*ifa+4];           //is order reversed? 0=yes, 1=no
                const int cpuL          =EdgeData[8*ifa+5];     // rank of cpuL
                const int cpuR          =EdgeData[8*ifa+6];     // rank of cpuR


                int increment;
                int idL,idR;
                int idxL,idxR;
                const int edgeID=ifa*ngl*Neq + i;   //for edge wise solution
                const int edgeIDX=ifa*ngl + i;      //for edge wise spatial values (BOTTOM)
                dfloat q1;
                dfloat q2;
                dfloat q3;

                    if (ireversed==0){
                        increment = (ngl-1)-i;
                    }else{
                        increment=i;
                    }


                dfloat qNodalL[Neq];
                dfloat qNodalR[Neq];
                qNodalL[0]=0.0;
                qNodalL[1]=0.0;
                qNodalL[2]=0.0;
                qNodalR[0]=0.0;
                qNodalR[1]=0.0;
                qNodalR[2]=0.0;



                if (procID == cpuL){
                    switch(isl){
                    case (0): //bottom side
                        idL = iel*ngl2*Neq+i;
                        idxL = iel*ngl2+i;
                        break;
                    case (2): //top side
                        idL = iel*ngl2*Neq+ngl2-ngl+i;
                        idxL = iel*ngl2+ngl2-ngl+i;
                        break;
                    case (3): //left side
                        idL = iel*ngl2*Neq+i*ngl;
                        idxL = iel*ngl2+i*ngl;
                        break;
                    case (1): //right side
                        idL = iel*ngl2*Neq+(i+1)*ngl-1;
                        idxL = iel*ngl2+(i+1)*ngl-1;
                        break;

                    }




                    qNodalL[0]=Q[idL];
                    qNodalL[1]=Q[idL+ngl2];
                    qNodalL[2]=Q[idL+ngl2+ngl2];
                }







                if (procID == cpuR){
                    switch(isr){
                    case (0): //bottom side
                        idR = ier*ngl2*Neq+increment;
                        idxR = ier*ngl2+increment;
                        break;
                    case (2): //top side
                        idR = ier*ngl2*Neq+ngl2-ngl+increment;
                        idxR = ier*ngl2+ngl2-ngl+increment;
                        break;
                    case (3): //left side
                        idR = ier*ngl2*Neq+increment*ngl;
                        idxR = ier*ngl2+increment*ngl;
                        break;
                    case (1): //right side
                        idR = ier*ngl2*Neq+(increment+1)*ngl-1;
                        idxR = ier*ngl2+(increment+1)*ngl-1;
                        break;

                    }
                    qNodalR[0]=Q[idR];
                    qNodalR[1]=Q[idR+ngl2];
                    qNodalR[2]=Q[idR+ngl2+ngl2];
                }









                // EXTERIOR BOUNDARY CASE!


                    if (cpuL==-1){

                        InitQNodal(x[idxR],y[idxR],q1,q2,q3,t,bL[edgeIDX]);
                        qNodalL[0]=q1;
                        qNodalL[1]=q2;
                        qNodalL[2]=q3;
                    }
                    if (cpuR==-1){

                        InitQNodal(x[idxL],y[idxL],q1,q2,q3,t,bR[edgeIDX]);
                        qNodalR[0]=q1;
                        qNodalR[1]=q2;
                        qNodalR[2]=q3;

                    }








                qL[edgeID]=qNodalL[0];
                qL[edgeID+ngl]=qNodalL[1];
                qL[edgeID+ngl+ngl]=qNodalL[2];

                qR[edgeID]=qNodalR[0];
                qR[edgeID+ngl]=qNodalR[1];
                qR[edgeID+ngl+ngl]=qNodalR[2];









            }//inner0 loop




        }//outer0 loop


}//end kernel
