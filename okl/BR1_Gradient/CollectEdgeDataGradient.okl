
kernel void CollectEdgeDataGradient(const int Nfaces,
                                    const int * restrict  EdgeData,
                                    const dfloat * restrict  qGradientX,
                                    const dfloat * restrict  qGradientY,
                                    const dfloat * restrict  ViscPara,
                                    dfloat * restrict  ViscParaL,
                                    dfloat * restrict  ViscParaR,
                                    dfloat * restrict  qGradientXL,
                                    dfloat * restrict  qGradientXR,
                                    dfloat * restrict  qGradientYL,
                                    dfloat * restrict  qGradientYR)
{
    for (int ifa=0; ifa<Nfaces; ifa++; outer0)
    {


        for(int i=0; i<ngl; i++; inner0)
        {
            const int iel           =EdgeData[8*ifa];       //left element
            const int ier           =EdgeData[8*ifa+1];       //right element
            const int isl           =EdgeData[8*ifa+2];       //side within left element
            const int isr           =EdgeData[8*ifa+3];      //side within right element
            const int ireversed     =EdgeData[8*ifa+4];           //is order reversed? 0=yes, 1=no
            const int cpuL          =EdgeData[8*ifa+5];     // rank of cpuL
            const int cpuR          =EdgeData[8*ifa+6];     // rank of cpuR
            int increment;
            int idL,idR;

            const int edgeID=ifa*ngl*Neq + i;   //for edge wise solution


            if (ireversed==0)
            {
                increment = (ngl-1)-i;
            }
            else
            {
                increment=i;
            }


            dfloat qNodalXL[Neq];
            dfloat qNodalXR[Neq];
            dfloat qNodalYL[Neq];
            dfloat qNodalYR[Neq];
            if (i==0)
            {
                ViscParaL[ifa]=zero;
                ViscParaR[ifa]=zero;
            }

            if (procID == cpuL)
            {
                switch(isl)
                {
                case (0): //bottom side
                    idL = iel*ngl2*Neq+i;
                    break;
                case (2): //top side
                    idL = iel*ngl2*Neq+ngl2-ngl+i;

                    break;
                case (3): //left side
                    idL = iel*ngl2*Neq+i*ngl;

                    break;
                case (1): //right side
                    idL = iel*ngl2*Neq+(i+1)*ngl-1;

                    break;

                }

                qNodalXL[0]=qGradientX[idL];
                qNodalXL[1]=qGradientX[idL+ngl2];
                qNodalXL[2]=qGradientX[idL+ngl2+ngl2];
                qNodalYL[0]=qGradientY[idL];
                qNodalYL[1]=qGradientY[idL+ngl2];
                qNodalYL[2]=qGradientY[idL+ngl2+ngl2];
                if (i==0)
                {
                    ViscParaL[ifa]=ViscPara[iel];
                }

            }


            if (procID == cpuR)
            {
                switch(isr)
                {
                case (0): //bottom side
                    idR = ier*ngl2*Neq+increment;

                    break;
                case (2): //top side
                    idR = ier*ngl2*Neq+ngl2-ngl+increment;

                    break;
                case (3): //left side
                    idR = ier*ngl2*Neq+increment*ngl;

                    break;
                case (1): //right side
                    idR = ier*ngl2*Neq+(increment+1)*ngl-1;

                    break;

                }

                qNodalXR[0]=qGradientX[idR];
                qNodalXR[1]=qGradientX[idR+ngl2];
                qNodalXR[2]=qGradientX[idR+ngl2+ngl2];
                qNodalYR[0]=qGradientY[idR];
                qNodalYR[1]=qGradientY[idR+ngl2];
                qNodalYR[2]=qGradientY[idR+ngl2+ngl2];
                if (i==0)
                {
                    ViscParaR[ifa]=ViscPara[ier];
                }
            }




// EXTERIOR BOUNDARY?
            if (cpuL==-1)
            {


                qNodalXL[0]=qGradientX[idR];
                qNodalXL[1]=zero;
                qNodalXL[2]=zero;
                qNodalYL[0]=qGradientY[idR];
                qNodalYL[1]=zero;
                qNodalYL[2]=zero;
                if (i==0)
                {
                    ViscParaL[ifa]=ViscPara[ier];
                    ViscParaR[ifa]=ViscPara[ier];
                }

            }


            if (cpuR==-1)
            {


                qNodalXR[0]=qGradientX[idL];
                qNodalXR[1]=zero;
                qNodalXR[2]=zero;
                qNodalYR[0]=qGradientY[idL];
                qNodalYR[1]=zero;
                qNodalYR[2]=zero;
                if (i==0)
                {
                    ViscParaL[ifa]=ViscPara[iel];
                    ViscParaR[ifa]=ViscPara[iel];
                }
            }


            qGradientXL[edgeID]=qNodalXL[0];
            qGradientXL[edgeID+ngl]=qNodalXL[1];
            qGradientXL[edgeID+ngl+ngl]=qNodalXL[2];

            qGradientXR[edgeID]=qNodalXR[0];
            qGradientXR[edgeID+ngl]=qNodalXR[1];
            qGradientXR[edgeID+ngl+ngl]=qNodalXR[2];


            qGradientYL[edgeID]=qNodalYL[0];
            qGradientYL[edgeID+ngl]=qNodalYL[1];
            qGradientYL[edgeID+ngl+ngl]=qNodalYL[2];

            qGradientYR[edgeID]=qNodalYR[0];
            qGradientYR[edgeID+ngl]=qNodalYR[1];
            qGradientYR[edgeID+ngl+ngl]=qNodalYR[2];


        }//inner0 loop




    }//outer0 loop


}//end kernel
