
kernel void calcNumFluxesGradient(const int Nfaces,const int * EdgeData,const dfloat * normalx,const dfloat * normaly,const dfloat *Scal, const dfloat * qL,const dfloat * qR, const dfloat * BL,const dfloat * BR,dfloat * SurfGradientsX,dfloat * SurfGradientsY)
{
        for (int ifa=0;ifa<Nfaces;ifa++;outer0){


            for(int i=0;i<ngl;i++;inner0){

                const int cpuL          =EdgeData[8*ifa+5];     // rank of cpuL
                const int cpuR          =EdgeData[8*ifa+6];     // rank of cpuR


                const int edgeID=ifa*ngl*Neq + i;           //for values!!

                const int edgeIDX=ifa*ngl + i;              //for normals!!
                const dfloat nx=normalx[edgeIDX];
                const dfloat ny=normaly[edgeIDX];
                const dfloat scaling=Scal[edgeIDX];

                dfloat NumFlux[Neq];

                const dfloat bL=BL[edgeIDX];
                const dfloat bR=BR[edgeIDX];

                dfloat hL;
                dfloat huL;
                dfloat hvL;
                dfloat hR;
                dfloat huR;
                dfloat hvR;
                if (cpuL == -1 ) {
                    hL=qR[edgeID];
                    huL=qR[edgeID+ngl];
                    hvL=qR[edgeID+ngl+ngl];

                }else{
                    hL=qL[edgeID];
                    huL=qL[edgeID+ngl];
                    hvL=qL[edgeID+ngl+ngl];
                }

                if (cpuR ==-1 ) {
                     hR=qL[edgeID];
                     huR=qL[edgeID+ngl];
                     hvR=qL[edgeID+ngl+ngl];
                }else{
                     hR=qR[edgeID];
                     huR=qR[edgeID+ngl];
                     hvR=qR[edgeID+ngl+ngl];
                }


                const dfloat HL = hL;
                const dfloat HR = hR;

                dfloat hLinv;
                if (hL>PosPresTOL){
                    hLinv =  1.f/hL;
                }else{
                    hLinv = 0.0;
                }
                dfloat hRinv;
                if (hR>PosPresTOL){
                    hRinv =  1.f/hR;
                }else{
                    hRinv = 0.0;
                }

                const dfloat HuL = HL * huL*hLinv ;
                const dfloat HuR = HR * huR*hRinv ;

                const dfloat HvL = HL * hvL*hLinv ;
                const dfloat HvR = HR * hvR*hRinv ;


                NumFlux[0]=0.5*(HL+HR );
                NumFlux[1]=0.5*(HuL+HuR );
                NumFlux[2]=0.5*(HvL+HvR );



                SurfGradientsX[edgeID]          =  nx * scaling*geomFace*  NumFlux[0];
                SurfGradientsX[edgeID+ngl]      =  nx * scaling*geomFace*  NumFlux[1];
                SurfGradientsX[edgeID+ngl+ngl]  =  nx * scaling*geomFace*  NumFlux[2];

                SurfGradientsY[edgeID]          =  ny * scaling*geomFace*  NumFlux[0];
                SurfGradientsY[edgeID+ngl]      =  ny * scaling*geomFace*  NumFlux[1];
                SurfGradientsY[edgeID+ngl+ngl]  =  ny * scaling*geomFace*  NumFlux[2];


              }
            }





}
