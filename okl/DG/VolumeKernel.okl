
kernel void VolumeKernel(const int Nelem, const dfloat * Jac,const dfloat * Y_xi,const dfloat * Y_eta,const dfloat * X_xi,const dfloat * X_eta,const dfloat * Q,const dfloat * restrict D,const dfloat * Bx,const dfloat * By,dfloat * Qt)
{



    for(int ie = 0; ie < Nelem; ie++; outer0)
    {



        shared dfloat s_F1[ngl][ngl];
        shared dfloat s_F2[ngl][ngl];
        shared dfloat s_F3[ngl][ngl];
        shared dfloat s_G1[ngl][ngl];
        shared dfloat s_G2[ngl][ngl];
        shared dfloat s_G3[ngl][ngl];
        shared dfloat s_D[ngl][ngl];
        shared dfloat s_Q1[ngl][ngl];
        shared dfloat s_Q2[ngl][ngl];
        shared dfloat s_Q3[ngl][ngl];




        for (int i=0; i<ngl; ++i;inner1){
            for (int j=0; j<ngl;++j;inner0){
                        const int id=j*ngl+i;
                        const int Fid = ie*ngl2*Neq   +j*ngl+i;

                        s_D[i][j]=D[id];
                        s_Q1[i][j]=Q[Fid];
                        s_Q2[i][j]=Q[Fid+ngl2];
                        s_Q3[i][j]=Q[Fid+ngl2+ngl2];

            }
        }

            barrier(localMemFence);

            // calcFluxes
            for (int i=0; i<ngl; ++i;inner1){
                for (int j=0; j<ngl;++j;inner0){

                        const int id=j*ngl+i;
                        const int xid=ie*ngl2   +j*ngl+i;

                        dfloat invQ1;

                         if (s_Q1[i][j]>PosPresTOL){
                            invQ1 = 1.f/s_Q1[i][j];
                         }else{
                            invQ1=0.0;
                            s_Q2[i][j]=0.0;
                            s_Q3[i][j]=0.0;
                         };


                        const dfloat F1 = s_Q2[i][j];
                        const dfloat F2 = s_Q2[i][j]*s_Q2[i][j]*invQ1 + 0.5*g_const*s_Q1[i][j]*s_Q1[i][j];
                        const dfloat F3 = s_Q3[i][j]*s_Q2[i][j]*invQ1;
                        const dfloat G1 = s_Q3[i][j];
                        const dfloat G2 = s_Q2[i][j]*s_Q3[i][j]*invQ1;
                        const dfloat G3 = s_Q3[i][j]*s_Q3[i][j]*invQ1 + 0.5*g_const*s_Q1[i][j]*s_Q1[i][j];

                        const dfloat r_Yeta=Y_eta[xid];
                        const dfloat r_Yxi=Y_xi[xid];
                        const dfloat r_Xeta=X_eta[xid];
                        const dfloat r_Xxi=X_xi[xid];


                        s_F1[i][j]=r_Yeta * F1 - r_Xeta* G1;
                        s_G1[i][j]=-r_Yxi * F1 + r_Xxi* G1;

                        s_F2[i][j]=r_Yeta * F2 - r_Xeta* G2;
                        s_G2[i][j]=-r_Yxi * F2 + r_Xxi* G2;

                        s_F3[i][j]=r_Yeta * F3 - r_Xeta* G3;
                        s_G3[i][j]=-r_Yxi * F3 + r_Xxi* G3;



                    }
                }

            barrier(localMemFence);

            for (int j=0; j<ngl; ++j;inner1){
                for (int i=0; i<ngl;++i;inner0){
                    dfloat FluxDeriv1=0.0;
                    dfloat FluxDeriv2=0.0;
                    dfloat FluxDeriv3=0.0;

	// unroll loop
                    occaUnroll(ngl)
                    for (int l=0; l<ngl; ++l){

                          FluxDeriv1+= s_D[l][i] * s_F1[l][j];
                          FluxDeriv1+= s_D[l][j] * s_G1[i][l];


                          FluxDeriv2+=s_D[l][i] * s_F2[l][j];
                          FluxDeriv2+=s_D[l][j] * s_G2[i][l];;



                          FluxDeriv3+=s_D[l][i] * s_F3[l][j];
                          FluxDeriv3+=s_D[l][j] * s_G3[i][l];


                     }


                        const int id  = ie*ngl2*Neq   +j*ngl+i;
                        const int xid=ie*ngl2   +j*ngl+i;

                        const dfloat r_Jac=Jac[xid];
                        const dfloat r_Bx=Bx[xid];
                        const dfloat r_By=By[xid];

                        Qt[id]              = -  r_Jac *FluxDeriv1;
                        Qt[id+ngl2]         = -  r_Jac *FluxDeriv2 - g_const *s_Q1[i][j]*r_Bx ;
                        Qt[id+ngl2+ngl2]    = -  r_Jac *FluxDeriv3 - g_const *s_Q1[i][j]*r_By;




                }
            }



    }



}

