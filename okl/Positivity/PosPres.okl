kernel void PosPres(const int Nelem,
                    const dfloat * restrict Qavg,
                    dfloat * restrict  Q)
{



    for(int iEo = 0; iEo < Nelem; iEo+=NEpad; outer0)
    {

        shared dfloat s_Havg[NEpad];
        shared dfloat s_HUavg[NEpad];
        shared dfloat s_HVavg[NEpad];
        shared dfloat s_theta[NEpad];

        shared dfloat s_H[NEpad][ngl][ngl];
        shared dfloat s_Hu[NEpad][ngl][ngl];
        shared dfloat s_Hv[NEpad][ngl][ngl];


// Very naive way to integrate over an element

        for (int ieLoc=0; ieLoc<NEpad; ++ieLoc; inner2)
        {
            for (int i=0; i<ngl; ++i; inner1)
            {
                for (int j=0; j<ngl; ++j; inner0)
                {
                    const int eleID     =   iEo + ieLoc;
                    if (eleID<Nelem)
                    {

                        const int Fid = eleID*ngl2*Neq   +j*ngl+i;

                        s_H[ieLoc][i][j] = Q[Fid];
                        s_Hu[ieLoc][i][j] = Q[Fid+ngl2];
                        s_Hv[ieLoc][i][j] = Q[Fid+ngl2+ngl2];
                        if ((i==0)&&(j==0)){
                            s_Havg[ieLoc]  =   Qavg[eleID*4];
                            s_HUavg[ieLoc] =   Qavg[eleID*4+1];
                            s_HVavg[ieLoc] =   Qavg[eleID*4++2];


                            const dfloat r_havg = s_Havg[ieLoc] ;
                            const dfloat r_hmin = Qavg[eleID*4++3] ;
                            if (r_havg == r_hmin)
                            {
                                s_theta[ieLoc] =  one;
                            }
                            else
                            {
                                s_theta[ieLoc] =  min(one,r_havg/(r_havg-r_hmin));
                            }

                        }




                    }

                }
            }
        }

        barrier(localMemFence);

// now that theta is found, update all values

        for (int ieLoc=0; ieLoc<NEpad; ++ieLoc; inner2)
        {
            for (int i=0; i<ngl; ++i; inner1)
            {
                for (int j=0; j<ngl; ++j; inner0)
                {
                    const int eleID     =   iEo + ieLoc;
                    if (eleID<Nelem)
                    {
                        const int id = eleID*ngl2*Neq   +j*ngl+i;


                        dfloat h_new =zero;
                        dfloat hu_new=zero;
                        dfloat hv_new=zero;

                        const dfloat r_h = s_H[ieLoc][i][j];
                        const dfloat r_hu = s_Hu[ieLoc][i][j];
                        const dfloat r_hv = s_Hv[ieLoc][i][j];
                        const dfloat r_hAvg = s_Havg[ieLoc];
                        const dfloat r_huAvg = s_HUavg[ieLoc];
                        const dfloat r_hvAvg = s_HVavg[ieLoc];
                        const dfloat r_theta = s_theta[ieLoc];

                        if (r_hAvg>zero)
                        {

                            h_new =  fabs(r_theta * ( r_h - r_hAvg ) + r_hAvg);



                            if (h_new > PosPresTOL)
                            {
                                hu_new = r_theta * (r_hu -  r_huAvg) +  r_huAvg;
                                hv_new = r_theta * (r_hv -  r_hvAvg) + r_hvAvg;
                            }
                            else
                            {
                                hu_new = zero;
                                hv_new = zero;

                            }





                        }
                        else
                        {
                            h_new=zero;
                            hu_new = zero;
                            hv_new = zero;

                        }




                        Q[id]=h_new;
                        Q[id+ngl2] =hu_new;
                        Q[id+ngl2+ngl2] = hv_new;
                    }
                }



            }
        }






    }



}
